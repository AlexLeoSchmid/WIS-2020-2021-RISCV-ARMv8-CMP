\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%additional packages
%\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{hyperref} 
\usepackage{url}   
%%fuer abkuerzungen begin
\usepackage[acronym,hyperfirst = false]{glossaries}
\glsdisablehyper
%\usepackage[acronym,acronymlists={main, abbreviationlist},shortcuts,toc,description,footnote]{glossaries}
\newglossary[clg]{abbreviationlist}{cyi}{cyg}{List of Abbreviations}
\newglossary[slg]{symbolslist}{syi}{syg}{Symbols}
\renewcommand{\firstacronymfont}[1]{\emph{#1}}
\renewcommand*{\glspostdescription}{}	% Punkt am Ende jeder Beschreibung entfernen
\renewcommand*{\acrnameformat}[2]{#2 (\acronymfont{#1})}	% Langform der Akronyme
\makeglossaries
\date{\today}
\input{glossary}
%%fuer abkuerzungen end 

        
\begin{document}

\title{ARMv8 advantages and disadvantages to RISC-V}

\maketitle

\begin{abstract}
text
\end{abstract}

\begin{IEEEkeywords}
keyword1, keyowrd2
\end{IEEEkeywords}

\section{Introduction}
\label{ref:introduction}
	\subsection{Overview}
	\subsection{Motivation}
	\subsection{Goal}

\section{Background}
\label{ref:background}
	\subsection{Instruction Set Architectures}
	\subsection{RISC}
	\subsection{ARM}
	text
	\subsection{RISC-V}
	text

\section{Concept and Methods}
\label{ref:concept}
	\subsection{Business Models}
	Who develops the CPU cores, how can you get access to them? Who supports chip manufacturers in designing a chip with that CPU core?
	\subsection{Complexity}
	Risc-V and ARMv8 are both \gls{RISC} based architectures and compared to \gls{CISC} they are much more limited and only writing into registers is supported. \gls{RISC} machines are having a lot of characteristics, which are not necessary to be completely implemented, but they can lead to a few advantages of \gls{RISC} compared to \gls{CISC}, like an simpler control unit and faster decode. \cite{George1990} \\
Even various \gls{RISC} \glspl{ISA} are different in complexity. To compare those differences, it is important to take a look into the RISC specific features and compare them in flexibility, amount and implementation. So the basic Instruction sets, with corresponding extensions are compared together with the different realisations and the comparison of two basic assembly instructions.
	\subsubsection{Instruction sets}
	While the ARMv8 is clearly defined in relation to the instruction set, RISC-V is there much more variable. In RISC-V the only necessary Instruction set is the Integer instruction set. Those base integer instructions cannot be redefined, only extended by more optional instruction sets. Additional to operations for the base \gls{ISA}, completely different extensions are available. Further details are in chapter extensibility.
This makes the RISC-V architecture only as complex as necessary, because all the gratuitous instructions are not implemented. \cite{Asanovic2016} \\
ARM instead is defining the ARMv8 architecture in a completely different way. The ARMv8 supports already much more extensions in the basic version, also called v8.0. To build a more complex CPU the ARMv8 also provides extensions like ARMv8.1, ARMv8.2,up to ARMv8.6 plus a few optional extensions, which are also further compared in the chapter extensibility. Becaue almost all the optional extensions of RISC-V are covered by the basic v8.0, the ARMv8, only from the instructions set of view, is at least as complex as a fully extended RISC-V architecture. 
%All those additional extensions like v8.1 etc. makes the architecture much more complex than the full extended RISC-V.
\cite{ArmManual} \\

\subsubsection{Instruction set implementations}
The different \glspl{ISA} are able to implement the explained instructions in different ways.
// The RISC-V architecture is able to implement the instruction sets in 3 different versions a 32-bit (RV32I), a 64-bit (RV64I) and a 128-bit version (RV128I).
While for the 32-bit and the 64-bit implementations are also multiple subversions available, RV32E, RV32G/RV64G and RV128I, which is the only 128-bit implementation so far. RV32I is a version with only 15 instead of 31 registers. The subversion RV32G/RV64G is less a own version of implementation than a stable release. The RV32G/RV64G is combining a basic \gls{ISA} (RV32I or RV64I) plus different selected standard extensions (IMAFD). \cite{Asanovic2016} \\
Also ARMv8 has, as expected, different implementations, as well. RISC-V defines the implementations based on a number followed by the extensions, which are implemented. ARMv8 does it in a different way, because there are all the standard extensions already in the basic version included.
ARMv8 provides 3 different implementations A64, A32 and T32. As mentioned A64 is the 64-bit version and A32, T32  are both 32-bit versions.
AARCH64 and AARCH32 are two different execution states in ARM (AARCH64 for 64-bit and AARCH32 for 32-bit) The execution states are supporting the A64 instruction set in AARCH64 or A32/T32 in AARCH32.\cite{ArmManual}\\

\subsubsection{registers and access}
To complete the overview in an maybe for users more abstract point of few, the basic assembler commands (load and read) are compared.\\

To load an value from the RISC-V register lw, lh or lb is called. lw means load word, which loads the complete register, lh means load halfword and loads only 16 bit, lb means load byte. All are built-on the same way and lh and lb can be extended by an U (LHU, LBU) to load them as an unsigned value. All instructions are taking 2 parameters, a temp register to store the value in and an address to load the value from. The address is a pointer to the register together with an offset.
In the same way the store instructions sw,sh and sb are working. sw means store word, sh store halfword and sb means store byte. The built-on is the same way as it is for the loading. But the left side of the command is the temp register to take the value from and the second parameter is the register to store the value in (again with an offset). \cite{Asanovic2016}
ARM instead has a few more instructions but the basics are almost the same. The (LDR) command can be extended by an B to load only an byte, SB to load a signed byte, H to load a half word, SH to load an signed halfword and SW to load a signed word. To store a value in a register there are 3 possible ways STR to store complete register, STRB to Store byte, STRH to store halfword. So far its the same as for RISC-V. These basic load and store commands are followed by a few more, to load/store pairs, non temporal pairs, unscaled offsets and much more. Because there is not such an possibility in RISC-V there is no comparison about them. \cite{ArmManual}

%Write some stuff comparing machine-level and supervisor level \cite{AndrewWaterman} with 3 basic architecture profiles (Application profil, real-time profil, microcontroller profil\cite{ArmManual} S. 36
%godbolt.org
%basic comparing between basic

	\subsection{Performance}
	What are the differences in code size? Can we accurately compare the execution speed of both ISAs?
	\subsection{Extensibility}
	What instruction set extensions are there for both ISAs? Who can develop new extensions?
	\subsection{Ecosystem}
	Which compilers support ARM and RISC-V? Which operating systems and libraries?


\section{Discussion}
\label{ref:discussion}
	\subsection{ARM}
	What are the advantages of ARM compared to RISC-V?
	\subsection{RISC-V}
	What are the advantages of RISC-V compared to ARM?
	\subsection{Future directions and challenges}
	How can we more accurately measure performance differences between ARM and RISC-V and how do ISA extensions affect performance?

\section{Conclusion and Outlook}
\label{ref:conclusion}
	\subsection{Summary of results}
	\subsection{Accuracy of results}
	\subsection{Future directions}

\subsection{Literaturverzeichnis}
Die Quellen befinden sich in der Datei \textit{biblography.bib}. 
Meine Quellen sind:l \cite{50years}, \cite{ArmManual}, \cite{hennessy2012computer}, \cite{WisconsinMadison2016} \cite{drechsler2020enhanced}, \cite{Asanovic2016}, \cite{IEEE2018} \cite{Dirvin2019}, \cite{Bandic2019}.

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
