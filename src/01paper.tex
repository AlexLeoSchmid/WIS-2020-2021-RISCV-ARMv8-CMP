\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%additional packages
%\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{hyperref} 
\usepackage{url}   
%%fuer abkuerzungen begin
\usepackage[acronym,hyperfirst = false]{glossaries}
\glsdisablehyper
%\usepackage[acronym,acronymlists={main, abbreviationlist},shortcuts,toc,description,footnote]{glossaries}
\newglossary[clg]{abbreviationlist}{cyi}{cyg}{List of Abbreviations}
\newglossary[slg]{symbolslist}{syi}{syg}{Symbols}
\renewcommand{\firstacronymfont}[1]{\emph{#1}}
\renewcommand*{\glspostdescription}{}	% Punkt am Ende jeder Beschreibung entfernen
%renewcommand*{\acrnameformat}[2]{#2 (\acronymfont{#1})}	% Langform der Akronyme
\makeglossaries
\date{\today}
\input{glossary}
%%fuer abkuerzungen end 

        
\begin{document}

\title{Advantages and disadvantages of the RISC-V ISA
(Instruction Set Architecture) in comparison to the
ARMv8 ISA}

\author{\IEEEauthorblockN{1\textsuperscript{st} Michael Schneider}
\IEEEauthorblockA{\textit{Faculity of Computer Science and Mathematics} \\
\textit{OTH Regensburg}\\
Regensburg, Germany \\
michael4.schneider@st.oth-regensburg.de
}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Florian Henneke}
\IEEEauthorblockA{\textit{Faculity of Computer Science and Mathematics} \\
\textit{OTH Regensburg}\\
Regensburg, Germany \\
florian.henneke@st.oth-regensburg.de
}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Alexander Schmid}
\IEEEauthorblockA{\textit{Faculity of Computer Science and Mathematics} \\
\textit{OTH Regensburg} \\
Regensburg, Germany \\
alexander2.schmid@st.oth-regensburg.de}
%\and
%\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
}

\maketitle

\begin{abstract}
text
\end{abstract}

\begin{IEEEkeywords}
keyword1, keyowrd2
\end{IEEEkeywords}

\section{Introduction}
\label{ref:introduction}
	\subsection{Topic}
	\subsection{Motivation}
	\subsection{Goal}
	\subsection{Overview of paper}

\section{Background}
\label{ref:background}
	\subsection{Instruction Set Architectures}
	An \gls{ISA} refers a specification of instructions that a computer's \gls{CPU} can execute.
	The \gls{ISA} defines the binary format of these instructions, their semantics and certain aspects of the assembler
	language associated with that \gls{ISA}.

	A program in it's binary form can be executed on any \gls{CPU} that implements the \gls{ISA} and runs the operating system
	for which the program was compiled for.

	As of 2020, there exist many competing \glspl{ISA}, which limits the portability of compiled software.
	Reasons for this fragmentation include the fact that a \gls{CPU}'s \gls{ISA} influences the \gls{CPU}'s development cost, performance and complexity
	and the fact that \glspl{ISA} are usually protected by patents owned by the developer of that \gls{ISA} (see chapter \ref{businessModels}).

	On desktop computers and servers, the x86-64 architecture has been traditionally dominant,
	while the ARM architecture is widely used in mobile and embedded devices.

	\subsection{RISC}
	x64 and ARM are examples for two different paradigms in \gls{ISA} design, the \gls{CISC} and \gls{RISC} architecture.
	Early designs of integrated microprocessors have featured powerful instructions with most instructions allowing access to memory,
	and a small number of registers, mainly to make programming in assembly easier \cite{George1990}.

	This approach became known as \gls{CISC} in contrast to newer designs using the \gls{RISC} approach.
	\gls{RISC} \glspl{ISA} feature a larger number of registers with simpler instructions.
	Most \gls{RISC} instructions only allow registers as operands with dedicated load and store instructions for accessing memory \cite{George1990}.

	The \gls{RISC} approach was initially favored due to improved performance and power efficiency \cite{George1990}.
	
	However, a recent empirical study comparing \gls{CISC} x86-64 and \gls{RISC} ARM processors shows no difference in performance or power efficiency
	for workloads exceeding those of embedded microcontrollers \cite{Blem2013}.

	\gls{RISC} remains the preferred approach for new \glspl{ISA} due to the lower complexity resulting in less expensive and faster
	development of new CPU designs \cite{George1990}. 

	\subsection{ARM}
	ARM (advanced RISC machines) is one of the most common \gls{RISC} based \glspl{ISA}. 1985 the first ARM processor, at this time named Acorn RISC Machine was released. In 1990 the ARM Ltd. like we know it now was born by a joint venture of Apple, VLSI Technology and Acorn. \cite{Levy2005}
	 Now ARM is one of the most licensed an most well known manufacturer of \glspl{ISA}. Especially for IOT and mobile devices ARM is very common and already in 2016 ARM has had 34\% of world wide shipped SoCs. \cite{Holdings2018}
	From the beginning till now ARM is strictly closed source, what means everybody who wants to develop a processor based on the ARM architecture has to pay for the license to be allowed to legally build the processor (see chapter \ref{businessModels}. ARM has a very long history (up to 35 years) of building architectures and this made it possible to give the ARMv8 as much features as it has, based on many extensions (discussed in chapter \ref{sec:extensibility}) and performance (see chapter \ref{performance}).
	
	\subsection{RISC-V}
	RISC-V is developed by UC Berkely and has a much shorter History than ARM. Its major designed to keep the things as simple as possible. RISC-V is as the name lets guess an \gls{RISC} based architecture as well as ARM is. 
	geschichte, ...
	open source, leichter und ggf kosteng√ºnstiger zu erstellen, ...

\section{Concept and Methods (Initial section written by Alexander Schmid)}
\label{ref:concept}

Given that the goal of this paper is to compare the two \glspl{ISA}
across a set of criteria that are relevant to semiconductor companies when evaluating which \gls{ISA} to use with a new CPU design,
the following section defines these criteria.

The first of these criteria is the \gls{ISA}'s \textbf{business model}. There are often a number of patents protecting an \glspl{ISA} that prohibit anyone not licensed
by the patent owner from distributing \glspl{CPU} that implement that \gls{ISA} \cite{Tang2011}.

Whether these patents exist and the licensing terms
are an important factor when deciding which \gls{ISA} to use.

The \gls{ISA}'s complexity refers to the amount of effort required to implement the \gls{ISA}. The more complex an \gls{ISA} is, the more developer
time is spent on implementing and verifying a \gls{CPU}'s compatibility to the \gls{ISA}, instead of optimizing the \gls{CPU} for performance and efficiency,
increasing a \gls{CPU}'s development cost. \cite{Patterson1980}

The next aspect is a \gls{CPU}'s \textbf{performance}. There are various aspects that make up a \gls{CPU}'s performance.
Among these are the code size and execution speed.
The \gls{CPU}'s \gls{ISA} influences each of these performance aspects to varying degrees. Chapter \ref{performance} elaborates
the extent of that influence and compares the two \glspl{ISA} in these performance aspects, where possible.

A program's code size is greatly influenced by the \gls{ISA}, since the instruction set and the compiler used are the only two factors that influence
code size. As such, the code size is an important factor to consider when choosing which \gls{ISA} to implement for a new processor design, especially
for microcontrollers that are usually very constrained in the size of their program memory.
For the other performance aspects, it is debatable to which extent they are influenced by the \gls{CPU}'s instruction set as opposed
to the concrete implementation of the CPU. \cite{Blem2013} \cite{Akram2017}

\glspl{ISA} often allow for a number of instruction set extensions that may or may not be implemented by a given \gls{CPU}. These usually allow
faster and more efficient processing of programs for a given use case, such as \gls{SIMD} extensions that optimize signal processing and media applications \cite[page 52]{Arm2020},
\gls{AES} extensions that optimize cryptography \cite{Arm2015} or \gls{ISA}-extensions with shorter instructions for applications that are constrained in program memory. \cite{Arm2005}
Having a small base instruction set with many fine grained extensions improves the flexibility of the \gls{ISA}, allowing \glspl{CPU} to be optimized for specific
use cases, increasing performance and efficiency for those use cases. \gls{ISA} extensions do however pose a disadvantage when distributing precompiled software
to end users, as a piece of software that uses a certain \gls{ISA} extension can't be executed on \glspl{CPU} that don't implement that extension, potentially
increasing the number of different versions of that software that need to be distributed.

An \gls{ISA}'s ecosystem refers to the software that supports that \gls{ISA}, especially compilers that compile to that \gls{ISA}, operating systems and libraries.
When developing a new \gls{CPU} it is preferrable to use an \gls{ISA} with a large ecosystem, in order to maximize the amount of software
that can run on that \gls{CPU}. This is especially important in consumer desktop and mobile devices where a large variety of software is to be executed.

	\subsection{Business Models (written by Florian Henneke)}
	\label{businessModels}
	%When taking a look at the business model of the two rivaling \glspl{ISA} one will detect two substantially different approaches. While ARM takes the traditional path of licensing its intellectual property to semiconductor companies, RISC-V stands out with the completely different way of publishing its \gls{ISA} in an open source manner. This includes giving away their \gls{ISA} definition for free, which raises the standard questions criticizing open source material.
	[Introduction shortend because of word limit]

	Beginning with the classic model of ARM, the following sections will cover the two license models: ARM sells its \glspl{ISA} in various licensing models. \cite{ARMLC} These are staggered in multiple levels of access. The 'Design Start' level includes free access to the IP-Core of the simplest ARM Chips Cortex-M0 and Cortex-M3 aswell as the corresponding toolchain and processor models. For a fee between \$0 and \$75K the IP-Core of the Cortex-A5 aswell as the permission for 'single use' chip production can be aquired. This allows the customer to produce and sell one type of chip for a single purpose e.g. a network controller. For every chip produced, a royality must be given to ARM. The 'Design Start' access level also includes a license for accessing a 'artisan physical IP library', a license for universities which includes teaching and prototyping and allows non commercial production of own chips without royalities in small volumes. At last there is an '\acrshort{FPGA}' license which is free and includes a \gls{FPGA} optimized version of the Cortex-M3 and M1. Production is not allowed with this license.

	%The next level of access is called 'Flexible Access' and contains two license models, one for \$0 to \$75K which allows one tape-out per year. On top of the entry price one pays per used processor design and a royality per produced chip. The other model starts at \$200K per year and uses the same payment additions as the first one. But it allows unlimited tape-outs and includes employee trainings, design tools and design support.
	[Removed short section due to word limit]

	Above those access levels, there only officially exists the 'Standard' licensing model. This means one makes a individual contract with ARM.
	Several articles from 2013 \cite{Demerjian2013}\cite{Demerjian2013a} talk about an older licensing model which contains special categories for higher access licenses. The highest of these, often referred as the 'Architectural' license is the only one that allows editing of the \gls{ISA} and developing completely freely. The most prominent companies with such a license are Qualcomm which develops and sells mobile phone chips and Apple who just announced a 'Apple Silicon' developed laptop chip based on ARM. \cite{Apple2020} The article also mentions that preparing a license of this form often takes about 6-24 months and states per-chip royalities of about 1-2.5\%. It also notices so called 'foundry contracts' where customers can buy silicon ready ARM designs in cooperation with a silicon foundry. The most prominent example here are the Mali GPUs. This offers customers a fast and easy way to expand their chip with, for example, graphic accelerators.

	In contrast to the ARM license model, RISC-V is published using the 'Creative Commons Attribution 4.0' license. \cite{Waterman2017}\cite{Waterman2017a} This license allows the user to 'share' and 'adapt'. This means you are free to copy and redistribute as well as modify, change, build upon and sell it commercially. It is not necessary to share changes in an open source manner and you are only restricted by the obligation to give credit to the original licensor. \cite{CC} An important addition is also, that the license cannot be revoked by the licensor. This means everything about RISC-V that is already published will always be free to use.
	Originally founded by Berkley University, the RISC-V \gls{ISA} standard is now managed by the nonprofit organization 'RISC-V International', founded in 2015. \cite{RVIAbout} As the statutes of the organization include, the association has 'no pecunuary, self-help or commercial purpose' \cite{RVIArt}. Running expenses and further development of the standard do however require a certain liquidity. This is ensured by a membership program surrounding the specification. \cite{RVIMem} Resembling the ARM licensing model, it contains three levels: 'Premier', 'Strategic' and 'Community'. Costing between \$2K and \$250K annually, these levels do not restrict access to the \gls{ISA}, but grant several levels of taking influence on the future development of the standard through seats in the 'Technical Steering Commitee', speaker slots on conferences and representation on the official RISC-V International website and blog. There are also three 'Strategic Directors', which are elected out of the 'Premier' and 'Strategic' Members and one Academic as well as one Communtiy Director, which is elected by the 'Communtiy' level of members. \cite{RVIAss}

	Besides taking influence in the development process, the membership also includes help in designing \gls{CPU} Cores, teaching for employees and more. It also allows the usage of the trademark 'RISC-V'.

	\subsection{Complexity (Michael Schneider)}
	\label{complexity}
	Risc-V and ARMv8 are both \gls{RISC} based architectures but still different in complexity e.g amount of different implementations and the way to extend the \gls{ISA}, the different instruction formats and assembly operations.
	In RISC-V the only mandatory instruction set is the Integer instruction set. Those base integer instructions cannot be redefined, only extended by optional instruction sets. \cite{Waterman2017} Further details about the extensions are in chapter \ref{sec:extensibility}.
	ARM instead defines the ARMv8 architecture in a completely different way. The ARMv8 already supports many more extensions in the basic version, also called v8.0. Further extensions are available in later versions, as explained in the chapter \ref{sec:extensibility}. \cite{Arm2020} 	
	%Because almost all the optional extensions of RISC-V are covered by the basic v8.0, the ARMv8, regarding only the instructions, is at least as complex as a fully extended RISC-V architecture. 
	%All those additional extensions like v8.1 etc. makes the architecture much more complex than the full extended RISC-V.

	The different \glspl{ISA} are able to implement the explained instruction sets in various ways.
	The RISC-V architecture is able to implement the instruction sets in 3 different word length, a 32-bit (RV32I), a 64-bit (RV64I) and a 128-bit version (RV128I).
	For the 32-bit and the 64-bit implementations are also multiple subversions available, RV32E and RV32G/RV64G. For 128-bit, RV128I is the only 128-bit implementation so far. RV32E is a version with only 15 instead of 31 registers. The subversion RV32G/RV64G is less a own version than a stable release. The RV32G/RV64G combines a basic \gls{ISA} (RV32I or RV64I) plus different selected standard extensions (IMAFD, explained in \ref{sec:extensibility}). \cite{Waterman2016} 
	Also ARMv8 has, different implementations,
	A64, A32 and T32. A64 is the 64-bit version and A32, T32  are both 32-bit versions.
	AArch64 and AArch32 are two different execution states in ARM (AArch64 for 64-bit and AArch32 for 32-bit). These execution states support the A64 instruction set in AArch64 and A32 and T32 in AArch32. While A32 uses fixed 32-bit instruction encodings, T32 is variable, which means it uses both 16-bit and 32-bit instructions. \cite{Arm2020}
	% wieder einkommentieren wen noch W√∂rter √ºbrig.	
	%This is good to optimize your code, because a common instruction selection rule says, if a 16-bit encoding and a 32-bit encoding are available, the 16-bit is the one you should use, to optimize the code density. \cite{Arm2020}
	
	To complete the overview in a, for users more abstract point of view, two basic assembler commands (load and store) and the different instruction formats are compared.
	To load a value from a RISC-V register, LW, LH or LB is used. The "L" means load and the following characters stand for word (32 bit), halfword (16 bit) and byte. LH and LB are signed and can be extended by an "U" (LHU, LBU) to load unsigned values. \cite{Waterman2017}
	All instructions take 2 parameters, a register to store the value in and an address to load the value from. The address consists of the value stored in a register with an immediate offset.
	The store instructions SW, SH and SB work in the same way. SW stands for store word, SH store halfword and SB means store byte. The commands are structured in the same way as the loading commands are. The left side of the command is the register to take the value from and the second parameter is the register, containing the address, and the offset, where the value should be stored.  \cite{Berkeley2019} 
	ARM instead has a few more instructions but the basics are almost the same. The (LDR) command can be extended by an B to load only a byte, SB to load a signed byte, H to load a half word, SH to load an signed halfword and SW to load a signed word. To store a value, there are 3 possible ways STR to store the complete register, STRB to store a byte and STRH to store a halfword. These basic load and store commands are followed by: load/store pairs, unscaled offsets and much more. \cite{Arm2020}

	The explained load and store instructions are together with all other instructions dedicated to different formats.
	In RISC-V (RV32I) the instructions are summarised to Branch instructions, jump instructions, instructions with immediates, arithmetic/logical ops, instructions with upper immediates.
	The arithmetic/logical ops are called R-Format instructions and RISC-V has 10 of them.  For the immediates (I-Format) RISC-V has 9 plus the 5 load instructions from above and EBREAK, ECALL as  environment and breakpoint calls. The store instructions are limited to 3 and the branch instructions to 6. 2 Upper Immediate instructions and only 1 jump instruction complete the RISC-V instructions in RV32I.\cite{Waterman2017}
	In the ARMv8 \gls{ISA} (A32) the instructions are structured in a different way.
	The branch instructions (10 -  5 for conditional and 5 for unconditional branches) is the only format, which is the same as in RISC-V and already this is bigger in ARM. Further ARMv8 has data-processing instructions (18 standard instructions, 10 shift instructions, 48 multiply instructions, 8 saturating instructions, 14 packing and unpacking instructions, 2 divide instructions and 13 miscellaneous data-processing instructions). PSTATE and banked register access instructions (5), 22 miscellaneous instructions and 20 instructions to generate and handle exceptions. To complete the ARMv8 instructions the store/load instructions are need to be counted as well. In ARMv8 there are 40 different instructions to load and store. \cite{Arm2020}
% count ob ich keine miscellaneous instructions doppelt hab, weils ja scho in den data-processing instructions drin san
	
	\subsection{Performance (Alexander Schmid)}
	\label{performance}
	Code size is the performance parameter most influenced by the \gls{ISA} and not by the \gls{CPU}'s implementation,
	given that the \gls{ISA} and the compiler are the only two factors that influence code size.
	Because of this, code size is the most meaningful performance aspect to compare when evaluating the performance of different \glspl{ISA}.
	Given that code size is most critical in embedded applications, the Embench benchmark suite is a good benchmark
	with which to compare code sizes \cite{Patterson2019}. It consists of a number of programs frequently used in embedded
	applications, such as CRC, signal filtering, AES and QR code reading \cite{Patterson2019}.
	When compiling the Embench suite for both RV32IMC as well as 32-bit ARM with the Thumb-2 extension for code compression (called T32 in ARMv8, see chapter \ref{complexity}) using GCC 7,
	the code for RISC-V is approximately 11\% larger than the code for ARM \cite{Perotti2020}.
	Part of this gap in code size can be explained by the relative immaturity of the RISC-V implementation of
	GCC. RISC-V support for GCC was introduced in 2017 and the code size of the Embench suite
	compiled for RISC-V is lower with newer versions of GCC, however it is still larger than the code generated for ARM as of 2019 \cite{Patterson2019}.

	In \cite{Perotti2020} an extension for RISC-V is introduced, called HCC, that contains a number of instructions
	aimed at reducing the code size of RISC-V. This extension brings the code size gap down to 2.2\% for the Embench suite
	and makes the RISC-V code smaller than ARM by 1.75\% in a proprietary IoT benchmark developed by Huawei. \cite{Perotti2020}
	
	For 64-bit code size, the SPEC CPU2006 benchmark, when compiled to both RV64C as well as ARM A64 using GCC 5.2,
	is over 20\% larger on ARM as compared to RISC-V \cite[page 62]{Waterman2016}.
	This difference is mainly caused by the fact that ARM does not include a compressed instruction set like T32 for 64-bit, while RISC-V does.
	Code size is less important in applications where 64-bit \glspl{CPU} are typically used, because these applications
	are not as constrained in program memory size as embedded applications. A more dense 64-bit instruction set does however allow better utilization of the instruction cache,
	leading to better execution time \cite[slide 46]{Celio2016}.

	An issue when comparing execution speed is that the implementation of a specific \gls{CPU} has a far greater impact than the \gls{ISA}.
	One way to isolate the influence of the ISA is by only comparing the dynamic instruction count.
	The dynamic instruction count refers to the number of instructions the \gls{CPU} executes when executing a specific program
	and, like code size, it is only influenced by the \gls{ISA} and compiler.

	For the SPECint portion of the SPEC CPU 2006 benchmark compiled with GCC 5.3, the dynamic instruction count is approximately
	10\% larger for RV64G as compared to ARM A64 \cite[slide 38]{Celio2016}.
	This difference can be explained by the presence of complex memory instructions in ARM that require multiple instructions
	for the same task in RISC-V \cite[slide 40]{Celio2016}.
	These instructions may however be split into multiple micro-operations on an ARM \gls{CPU} via a process called micro-op generation \cite[slide 40]{Celio2016}.
	Similarly, an optimizing RISC-V CPU might execute multiple instructions that often occur together as if they were one instruction.
	This process is called macro-op fusion \cite[slide 16]{Celio2016}.
	When accounting for both micro-op generation as well as macro-op fusion, there is no significant difference in cycle count between RISC-V and ARM
	in the aforementioned SPECint benchmark \cite[slide 38]{Celio2016}.

	\subsection{Extensibility (Michael Schneider)}\label{sec:extensibility}
Extensibility is very important to build an tailor a CPU to the specified needs. Therefore \glspl{ISA} like RISC-V and ARMv8 define extensions in different ways. While RISC-V defines the basic integer instructions as only mandatory instruction set \cite{Waterman2017}, ARMv8 defines the more extended ARMv8.0 as there basic version \cite{Arm2020}.

RISC-V supports additional to the integer instructions different extensions. To mark the different implemented extensions, representable letter are used. 13 extensions are provided and everyone adds a new feature to the \gls{ISA}. The M extension for integer multiplication and division, A extension for atomic instructions (needs additional hardware to be emulated), C extension for compressed instructions, B extension for bit manipulations, J extension to understand dynamically translated languages, T extension to work with transactional memory, P extension for Packed-SIMD instructions and the N extension to support User-Level interrupts. To work with further number formats (floats, vectors) additional to standard integers, V extension (vectors), F extension (single-precision floating-point), D extension (double-precision floating-point), Q extension (quad-precision floating-point) and D extension (decimal floating-point) are defined. The implemented extensions further gives the name to the \gls{ISA}, e.g. if single floating-points and vectors extend a RV32I together with the integer multiplication, the \gls{ISA} will be named RV32IMFV. \cite{Waterman2017}

ARM provides extensions in a different way. The \gls{ISA} has a base version which contains almost all extensions of RISC-V, called ARMv8.0. The ARMv8.0 is already able to work with vectors and floating-points and it is also able to multiply and divide integers. The higher versions of ARMv8 (ARMv8.1 up to ARMv8.6) add further additional requirements and architectural features. Only the version ARMv8.4 adds only architectural features and no further requirements. \cite{Arm2020}

Additional to the different versions of the \gls{ISA}, both provide to create custom extensions.
To create a RISC-V custom extension two steps are important: defining the instructions and include the instruction to the application \cite{Limited2019}. To realise these steps different tools can be used, for example the OVP APIs, which are helpful to simulate the extended processor model for simpler testing and creating a custom instruction \cite{Imperas}.

To define the instructions, the first step is the decode of the instruction, to define the fixed fields for instruction class and the fields for source and result register. Later on the defined decoding will be used to decode the instructions from the PC. The instruction behaviour can be done in 2 different ways either by simply using a C algorithm function or using the VMI Morph Time Functions which is the recommended approach. Finally the custom instructions can be used in C applications after it is added to the processor model. \cite{Limited2019}

ARM added also the possibility to create customized extensions. So far its only supported for Cortex-M33, but in 2021 ARM want to support it in the new Cortex-M55 as well. Accelerators can be categorized in the 3 different types. Memory mapped accelerators (connected to memory bus), coprocessor interface (allows to build closely coupled accelerators) and tightly to the CPU coupled accelerators. 
While decoupled memory mapped accelerators runs parallel and unaffected from the CPU, coprocessor and tightly coupled accelerators interact with the CPU and further tightly coupled accelerators are not able to run in parallel with the CPU. To build one of the 3 types of custom instruction only two steps are mandatory to do: 
\begin{enumerate}
\item "Providing a configuration file that lists the regions you want to use for adding your own custom instructions." \cite[page 4]{LauranneChoquin2020}
\item "Building the datapath for your own custom instructions and integrating
it into the configuration space." \cite[page 4]{LauranneChoquin2020}
\end{enumerate}
To finally decode the instruction and control the data path, the logic is automatically configured. \cite{LauranneChoquin2020}
	\subsection{Ecosystem}
	Which compilers support ARM and RISC-V? Which operating systems and libraries?


\section{Discussion}
\label{ref:discussion}
	\subsection{Extensibility} \label{dis:Extensibility}
	To discuss the extensibility of the architectures, two different ways to extend \glspl{ISA} need to be viewed. The RISC-V architecture has only one mandatory component (integer instruction set) \cite{Waterman2017}, while the basic ARM version (ARMv8.0) supports already many extension of RISC-V \cite{Arm2020}. 
	This results for RISC-V in an only as complex as needed CPU, because only the mandatory instruction sets have to be implemented \cite{Waterman2017}. The ARM version instead, which includes a big amount of instructions \cite{Arm2020}, results in an maybe more complex CPU (unnecessary implemented instructions). Related to extension realisation \ref{dis:Extensibility}, the ARM \gls{ISA} force you to implement instructions and features which are maybe not mandatory for the use of the CPU, but in the future they could be useful. This prevent to produce a new CPU as it would be the case by a very hard bounded RISC-V, with only the mandatory extensions implemented. \cite{Waterman2017} \cite{Arm2020}
	
	ARM also has the bigger set of instruction sets, extensions and operations compared to RISC-V, as it's shown in \ref{sec:extensibility}, what makes it better adjustable for more complex CPUs as with the limitations of RISC-V.

	In form of custom extensions it depends on the personal amenity. While ARM is very strict and a official witepaper \cite{LauranneChoquin2020} defines the way to do, RISC-V doesn't define a official way and there are a lot of tool triggered projections like the one from Imperas \cite{Limited2019} are given, but the loose definition of RISC-V makes it, at least for me a bit more complex to understand the process.
	
	\subsection{complexity}
The complexity is influenced by different aspects, as shown in \ref{complexity}.
While the concept of extensions leads to an easier CPU for RISC-V, the possible overhead of ARM could be a solid solution for the future \ref{dis:Extensibility}.
	Because ARM has much more instructions its more difficult to understand all the difference between every single instruction. In RISC-V the instructions are much more limited and the difference between each instruction is much more clean. \ref{complexity}
	
	The different instructions give the possibility to write the assembly code int more different ways, but it makes it also harder to understand all the differences between the instructions. That ARMv8 has more instructions can also be reduced to the different models of the extensions \ref{sec:extensibility} and the amount of instruction and formats \ref{complexity}.
ARM has much more instruction formats with much more instructions which makes it more complex to build, but if its done its more restrict for the future. Complex features which are maybe not supported in RISC-V or which are not implemented, because the are obsolete, are part of the version of ARM. \cite{Waterman2017} \cite{Arm2020}
	
	\subsection{Advantages of ARM}
	What are the advantages of ARM compared to RISC-V?
	%- more different instructions makes the assembler code in a good written way smaller and more performant
	\subsection{Advantages of RISC-V}
	%- lower amount of basic instruction sets and only optional extensions makes it less complex to implement.
	%- less instruction formats makes it more easy to build
	%- less different instructions makes the familiarization with programming easier
	What are the advantages of RISC-V compared to ARM?
	\subsection{Future directions and challenges}
	How can we more accurately measure performance differences between ARM and RISC-V and how do ISA extensions affect performance?

\section{Conclusion and Outlook}
\label{ref:conclusion}
	\subsection{Summary of results}
	\subsection{Interpretation of results}
	\subsection{Future directions}


\section{Overview of Literature}
Alexander Schmid \cite{Akram2017} \cite{Arm2020} \cite{Asanovic2014} \cite{HeuiLee2001} \cite{Patterson2019} \cite{Perotti2020} \cite{Shore2015} \cite{Waterman2016} \cite{Xu2003}

Florian Henneke \cite{Waterman2016} \cite{Ryzhyk2006} \cite{Asanovic2014} \cite{Furber2000} \cite{Microsoft2020} \cite{Greenwaves2020} \cite{Aws2020} \cite{Microsoft2020}

Michael Schneider \cite{Waterman2017} \cite{Arm2020} \cite{George1990} \cite{Waterman2016} \cite{50years} \cite{hennessy2012computer} \cite{drechsler2020enhanced} \cite{WisconsinMadison2016} \cite{IEEE2018} \cite{Dirvin2019} \cite{Bandic2019} \cite{Berkeley2019}

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
