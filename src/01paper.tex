\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%additional packages
%\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{hyperref} 
\usepackage{url}   
%%fuer abkuerzungen begin
\usepackage[acronym,hyperfirst = false]{glossaries}
\glsdisablehyper
%\usepackage[acronym,acronymlists={main, abbreviationlist},shortcuts,toc,description,footnote]{glossaries}
\newglossary[clg]{abbreviationlist}{cyi}{cyg}{List of Abbreviations}
\newglossary[slg]{symbolslist}{syi}{syg}{Symbols}
\renewcommand{\firstacronymfont}[1]{\emph{#1}}
\renewcommand*{\glspostdescription}{}	% Punkt am Ende jeder Beschreibung entfernen
\renewcommand*{\acrnameformat}[2]{#2 (\acronymfont{#1})}	% Langform der Akronyme
\makeglossaries
\date{\today}
\input{glossary}
%%fuer abkuerzungen end 

        
\begin{document}

\title{ARMv8 advantages and disadvantages to RISC-V}

\maketitle

\begin{abstract}
text
\end{abstract}

\begin{IEEEkeywords}
keyword1, keyowrd2
\end{IEEEkeywords}

\section{Introduction}
\label{ref:introduction}
	\subsection{Overview}
	\subsection{Motivation}
	\subsection{Goal}

\section{Background}
\label{ref:background}
	\subsection{Instruction Set Architectures}
	\subsection{RISC}
	\subsection{ARM}
	text
	\subsection{RISC-V}
	text

\section{Concept and Methods}
\label{ref:concept}
	\subsection{Business Models}
	Who develops the CPU cores, how can you get access to them? Who supports chip manufacturers in designing a chip with that CPU core?
	\subsection{Complexity (written by Michael Schneider)}
	Risc-V and ARMv8 are both \gls{RISC} based architectures. Compared to \gls{CISC} based architectures they are less powerful in their individual instructions and they are operating on register. \gls{RISC} machines have a lot of characteristics, which are not necessary to be completely implemented, but they can lead to different advantages of \gls{RISC}, if they are, like a simpler control unit and faster decoding. \cite{George1990} \\
Various \gls{RISC} \glspl{ISA} are different in complexity. To compare those differences, the basic instruction sets with corresponding extensions, the different realisations and two basic assembly instructions will be covered in the next chapters.
	\subsubsection{Instruction sets}
	In RISC-V the only mandatory instruction set is the Integer instruction set. Those base integer instructions cannot be redefined, only extended by optional instruction sets. Further details about the extensions are in chapter \ref{sec:extensibility}. This concept makes the RISC-V architecture only as complex as necessary, because the \gls{ISA} can be tailored to a specific application. \cite{Asanovic2016} \\
ARM instead defines the ARMv8 architecture in a completely different way. The ARMv8 alread supports many more extensions in the basic version, also called v8.0. Further extensions are available in later versions, as explained in the chapter \ref{sec:extensibility}. \cite{ArmManual} \\
Because almost all the optional extensions of RISC-V are covered by the basic v8.0, the ARMv8, regarding only the instructions, is at least as complex as a fully extended RISC-V architecture. 
%All those additional extensions like v8.1 etc. makes the architecture much more complex than the full extended RISC-V.


\subsubsection{Instruction set implementations}
The different \glspl{ISA} are able to implement the explained instruction sets in various ways.
The RISC-V architecture is able to implement the instruction sets in 3 different word length, a 32-bit (RV32I), a 64-bit (RV64I) and a 128-bit version (RV128I).
For the 32-bit and the 64-bit implementations are also multiple subversions available, RV32E and RV32G/RV64G. For 128-bit, RV128I is the only 128-bit implementation so far. RV32E is a version with only 15 instead of 31 registers. The subversion RV32G/RV64G is less a own version than a stable release. The RV32G/RV64G is combining a basic \gls{ISA} (RV32I or RV64I) plus different selected standard extensions (IMAFD). \cite{Asanovic2016} \\
Also ARMv8 has, different implementations,
A64, A32 and T32. A64 is the 64-bit version and A32, T32  are both 32-bit versions.
AArch64 and AArch32 are two different execution states in ARM (AArch64 for 64-bit and AArch32 for 32-bit). These execution states support the A64 instruction set in AArch64 and A32 and T32 in AArch32.\cite{ArmManual}\\

\subsubsection{registers and access}
To complete the overview in a, for users more abstract point of view, two basic assembler commands (load and store) are compared.
To load a value from a RISC-V register, LW, LH or LB is used. The "L" means load and the following characters stand for word (32 bit), halfword (16 bit) and byte. LH and LB are signed and can be extended by an "U" (LHU, LBU) to load unsigned values. All instructions take 2 parameters, a register to store the value in and an address to load the value from. The address consists of the value stored in a register with an immediate offset.
The store instructions SW, SH and SB work in the same way. SW stands for store word, SH store halfword and SB means store byte. The commands are structured in the same way as the loading commands are. The left side of the command is the register to take the value from and the second parameter is the register, containing the address, and the offset, where the value should be stored. \cite{Asanovic2016} \\
ARM instead has a few more instructions but the basics are almost the same. The (LDR) command can be extended by an B to load only a byte, SB to load a signed byte, H to load a half word, SH to load an signed halfword and SW to load a signed word. To store a value, there are 3 possible ways STR to store the complete register, STRB to store a byte and STRH to store a halfword. These basic load and store commands are followed by: load/store pairs, unscaled offsets and much more. Because there is no such possibility in RISC-V, there is no comparison about them. \cite{ArmManual}

%Todo: compare maybe the setup of the ARM instructions (are there more different/complex ways to use them??)

%Write some stuff comparing machine-level and supervisor level \cite{AndrewWaterman} with 3 basic architecture profiles (Application profil, real-time profil, microcontroller profil\cite{ArmManual} S. 36
%godbolt.org
%basic comparing between basic

	\subsection{Performance}
	What are the differences in code size? Can we accurately compare the execution speed of both ISAs?
	\subsection{Extensibility}\label{sec:extensibility}
	What instruction set extensions are there for both ISAs? Who can develop new extensions?
	\subsection{Ecosystem}
	Which compilers support ARM and RISC-V? Which operating systems and libraries?


\section{Discussion}
\label{ref:discussion}
	\subsection{ARM}
	What are the advantages of ARM compared to RISC-V?
	\subsection{RISC-V}
	What are the advantages of RISC-V compared to ARM?
	\subsection{Future directions and challenges}
	How can we more accurately measure performance differences between ARM and RISC-V and how do ISA extensions affect performance?

\section{Conclusion and Outlook}
\label{ref:conclusion}
	\subsection{Summary of results}
	\subsection{Accuracy of results}
	\subsection{Future directions}

\subsection{Literaturverzeichnis}
Die Quellen befinden sich in der Datei \textit{biblography.bib}. 
Meine Quellen sind:
 \cite{George1990} \cite{Asanovic2016} \cite{ArmManual}
 \cite{50years} \cite{hennessy2012computer} \cite{drechsler2020enhanced} \cite{WisconsinMadison2016}  \cite{IEEE2018} \cite{Dirvin2019} \cite{Bandic2019} \cite{ISAfree} \cite{RISC-Assembly} \cite{AndrewWaterman}

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
