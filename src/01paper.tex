\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%additional packages
%\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
%Added option hyphens to seperate links at -
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref} 
%\usepackage{url}
%%fuer abkuerzungen begin
\usepackage[acronym,hyperfirst = false]{glossaries}
\glsdisablehyper
%\usepackage[acronym,acronymlists={main, abbreviationlist},shortcuts,toc,description,footnote]{glossaries}
\newglossary[clg]{abbreviationlist}{cyi}{cyg}{List of Abbreviations}
\newglossary[slg]{symbolslist}{syi}{syg}{Symbols}
\renewcommand{\firstacronymfont}[1]{\emph{#1}}
\renewcommand*{\glspostdescription}{}	% Punkt am Ende jeder Beschreibung entfernen
%renewcommand*{\acrnameformat}[2]{#2 (\acronymfont{#1})}	% Langform der Akronyme
\makeglossaries
\date{\today}
\input{glossary}
%%fuer abkuerzungen end 

        
\begin{document}

\title{Advantages and disadvantages of the RISC-V ISA
(Instruction Set Architecture) in comparison to the
ARMv8 ISA}

\author{\IEEEauthorblockN{1\textsuperscript{st} Michael Schneider}
\IEEEauthorblockA{\textit{Faculity of Computer Science and Mathematics} \\
\textit{OTH Regensburg}\\
Regensburg, Germany \\
michael4.schneider@st.oth-regensburg.de
}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Florian Henneke}
\IEEEauthorblockA{\textit{Faculity of Computer Science and Mathematics} \\
\textit{OTH Regensburg}\\
Regensburg, Germany \\
florian.henneke@st.oth-regensburg.de
}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Alexander Schmid}
\IEEEauthorblockA{\textit{Faculity of Computer Science and Mathematics} \\
\textit{OTH Regensburg} \\
Regensburg, Germany \\
alexander2.schmid@st.oth-regensburg.de}
%\and
%\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
}

\maketitle

\renewcommand{\abstractname}{Abstract (Florian Henneke)}
\begin{abstract}
	Today RISC-V gets much attention in tech media, as a new, open \gls{ISA}, whereas ARMs ARMv8 archtitecture is the de facto standard in the sector of \gls{RISC} based silicon. Because this sector is still growing and expanding into x86-64 dominated sectors, many chip designers will newly evaluate which architecture to use. This paper compares ARMs ARMv8 and the new RISC-V \gls{ISA} under multiple aspects: business model, complexity, performance, extensibility and ecosystem. Later on it will discuss these ascpects and will conclude that both platforms are equal rivals: ARM has a more complex base \gls{ISA} than RISC-V, their performance is very close, RISC-V can be expanded more easily and freely, ARM offers a much bigger ecosystem, which however comes at a higher entry price. In addition, RISC-V does not yet offer a good and standardized end user environment in form of operating systems, which may be its biggest downside.
\end{abstract}

\begin{IEEEkeywords}
ARM, ARMv8, RISC-V, RISC, CISC, ISA, business model, licensing, complexity, instruction formats, performance, code size, execution speed, extensibility, ecosystem, operating system, compiler toolchain, design software, verification
\end{IEEEkeywords}

\section{Introduction (Florian Henneke)}
\label{ref:introduction}
	In 1993, Intel became the worlds largest semiconductor company \cite{ICInsights2011} dominating the industry for many future years \cite{Blem2013}. In the following years they were able to hold this position and qualify the \gls{CISC} based x86 architecture as the quasi standard in home and server applications. Many other \glspl{ISA} were created in this time span, but couldn't achieve the same importance as Intels architecture \cite[page 3-14]{Waterman2016}. 
	
	In 1981 Berkeley University had developed the first version of a \gls{RISC} architecture, called RISC-I and had proven comparable performance to \gls{CISC} \cite[page 2f]{Ryzhyk2006}. This lead to the launch of the first commercial ARM processor in 1985 \cite[page 2f]{Ryzhyk2006}. But it took until 2011 that ARM processors left their niche presence and became pupular with the rise of mobile devices and the IOT sector \cite[Qualcomm representing the rise of ARM silicon]{ICInsights2011a}\cite{ICInsights2012}. Today even laptops \cite{Apple2020} and servers \cite{ARMN1} are ARM based. This results in up to 50\% of sold microprocessors in 2020 beeing based on RISC architecure \cite{ICInsights2020}.

	With the still rising importance of \gls{RISC} architecures and the increasing public interest in a new, open, probably game changing and also founded by Berkeley University \gls{ISA} called RISC-V, it is now  time to compare the newcomer to the dominating ARM \gls{RISC} \gls{ISA}.

	This paper will start with the background on \gls{CPU} architectures (\ref{ref:background}) and will proceed to examine the aspects \textbf{business model} (\ref{businessModels}), \textbf{complexity} (\ref{complexity}), \textbf{performance} (\ref{performance}), \textbf{extensibility} (\ref{sec:extensibility}) and \textbf{ecosystem} (\ref{ecosystem}) of the newest ARM architecture ARMv8 and the RISC-V architecture. Afterwards it will discuss these points from a chip manufacturers point of view (\ref{ref:discussion}) and will give a summary (\ref{ref:interpretation}) as well as a look into the future (\ref{ref:future}).

\section{Background}
\label{ref:background}
	\subsection{Instruction Set Architectures (Alexander Schmid)}
	An \gls{ISA} refers to a specification of instructions that a computer's \gls{CPU} can execute.
	The \gls{ISA} defines the binary format of these instructions, their semantics and certain aspects of the assembler
	language associated with that \gls{ISA} \cite[page 20-23]{Stokes2006}.
	A program in its binary form can be executed on any \gls{CPU} that implements the \gls{ISA} and runs the operating system
	for which the program was compiled \cite[page 71]{Stokes2006}.

	As of 2020, there exist many competing \glspl{ISA}, which limits the portability of compiled software.
	Reasons for this fragmentation include the fact that a \gls{CPU}'s \gls{ISA} influences the \gls{CPU}'s development cost, performance (see chapter \ref{performance})
	and complexity (see chapter \ref{complexity}). Another reason is the fact that \glspl{ISA} are usually protected by patents owned by the developer of that \gls{ISA} (see chapter \ref{businessModels}).

	On desktop computers and servers, the x86-64 architecture has been traditionally dominant,
	while the ARM architecture is widely used in mobile and embedded devices \cite{Blem2013}.

	\subsection{RISC (Alexander Schmid)}
	x86-64 and ARM are examples for two different paradigms in \gls{ISA} design, the \gls{CISC} and \gls{RISC} architecture.
	Early designs of integrated microprocessors have featured powerful instructions with most of them allowing access to memory,
	and a small number of registers \cite{George1990}. This is mainly done to make programming in assembly language easier \cite[page 73]{Stokes2006}.

	This approach became known as \gls{CISC} in contrast to newer designs using the \gls{RISC} approach.
	\gls{RISC} \glspl{ISA} feature a larger number of registers with simpler instructions.
	Most \gls{RISC} instructions only allow registers as operands with dedicated load and store instructions for accessing memory \cite{George1990}.

	The \gls{RISC} approach was initially favored due to improved performance and power efficiency \cite{George1990}.
	
	However, a recent empirical study comparing \gls{CISC} x86-64 and \gls{RISC} ARM processors shows no difference in performance or power efficiency
	for workloads exceeding those of embedded microcontrollers \cite{Blem2013}.

	\gls{RISC} remains the preferred approach for new \glspl{ISA} due to the lower complexity resulting in less expensive and faster
	development of new CPU designs \cite{George1990}. 

	\subsection{ARM (Michael Schneider)}
	In 1985 the first ARM processor, at this time named Acorn RISC Machine, was released in 1990 and the ARM Ltd. was born by a joint venture of Apple, VLSI Technology and Acorn \cite{Levy2005}.

	 Now ARM is one of the most licensed \glspl{ISA}. Especially for IOT and mobile devices ARM is very common, wherefore 2016 34\% of shipped SoCs where ARM based. \cite[slide 7-10]{Holdings2018}

	From the beginning until now ARM is strictly closed source, which means everybody who wants to develop a processor based on the ARM architecture has to get a license to legally build a processor (see chapter \ref{businessModels}). ARM has a very long history (up to 35 years) of building architectures and this made it possible to give the ARMv8 a big feature set, good performance (see chapter \ref{performance}), as well as the ability to add extensions (discussed in chapter \ref{sec:extensibility}).
	
	\subsection{RISC-V (Michael Schneider)}
	In 2010 the UC Berkeley with director Prof. David Patterson, more precisely professor Krste Asanovi\'{c} and the graduate students Yunsup Lee and Andrew Waterman, started the foundation of the RISC-V \gls{ISA}. The start of the architecture was made in the \gls{Par Lab}, where also the Chisel hardware construction language, which was used to design many RISC-V processors, was developed. As it was only a five-year project funded by Intel and Microsoft, later on in 2015 the RISC-V Foundation was founded to create a community of software and hardware innovators and later, in 2018 a collaboration with the Linux Foundation was announced. \cite{International2020}

	Further, RISC-V is developed as a completely open ISA, means it is freely available to academia and industry. The \gls{ISA} tries to avoid "over-architecting" by providing only a small base \gls{ISA} together with different extensions. \cite[page 1]{Waterman2017}
	
\section{Concept and Methods (Initial Section by Alexander Schmid)}
	\label{ref:concept}

Given that the goal of this paper is to compare the two \glspl{ISA}
across a set of criteria that are relevant to semiconductor companies when evaluating which \gls{ISA} to use with a new CPU design,
the following section defines these criteria.

The first of these criteria is the \gls{ISA}'s \textbf{business model}. There are often a number of patents protecting an \glspl{ISA} that prohibit anyone not licensed
by the patent owner from distributing \glspl{CPU} that implement that \gls{ISA} \cite{Tang2011}.

Whether these patents exist and the licensing terms
are an important factor when deciding which \gls{ISA} to use.

The \gls{ISA}'s complexity refers to the amount of effort required to implement the \gls{ISA}. The more complex an \gls{ISA} is, the more developer
time is spent on implementing and verifying a \gls{CPU}'s compatibility to the \gls{ISA}, instead of optimizing the \gls{CPU} for performance and efficiency,
increasing a \gls{CPU}'s development cost. \cite{Patterson1980}

The next aspect is a \gls{CPU}'s \textbf{performance}. There are various aspects that make up a \gls{CPU}'s performance.
Among these are the code size and execution speed.
The \gls{CPU}'s \gls{ISA} influences each of these performance aspects to varying degrees. Chapter \ref{performance} elaborates
the extent of that influence and compares the two \glspl{ISA} in these performance aspects, where possible.

A program's code size is greatly influenced by the \gls{ISA}, since the instruction set and the compiler used are the only two factors that influence
code size. As such, the code size is an important factor to consider when choosing which \gls{ISA} to implement for a new processor design, especially
for microcontrollers that are usually very constrained in the size of their program memory.
For the other performance aspects, it is debatable to which extent they are influenced by the \gls{CPU}'s instruction set as opposed
to the concrete implementation of the CPU. \cite{Blem2013} \cite{Akram2017}

\glspl{ISA} often allow for a number of instruction set \textbf{extensions} that may or may not be implemented by a given \gls{CPU}. These usually allow
faster and more efficient processing of programs for a given use case, such as \gls{SIMD} extensions that optimize signal processing and media applications \cite[page 52]{Arm2020},
\gls{AES} extensions that optimize cryptography \cite{Arm2015} or \gls{ISA}-extensions with shorter instructions for applications that are constrained in program memory. \cite{Arm2005}
Having a small base instruction set with many fine grained extensions improves the flexibility of the \gls{ISA}, allowing \glspl{CPU} to be optimized for specific
use cases, increasing performance and efficiency for those use cases. \gls{ISA} extensions do however pose a disadvantage when distributing precompiled software
to end users, as a piece of software that uses a certain \gls{ISA} extension can't be executed on \glspl{CPU} that don't implement that extension, potentially
increasing the number of different versions of that software that need to be distributed.

An \gls{ISA}'s \textbf{ecosystem} refers to the software that supports that \gls{ISA}, especially compilers that compile to that \gls{ISA}, operating systems and libraries.
When developing a new \gls{CPU} it is preferrable to use an \gls{ISA} with a large ecosystem, in order to maximize the amount of software
that can run on that \gls{CPU}. This is especially important in consumer desktop and mobile devices where a large variety of software is to be executed.

	\subsection{Business Models (Florian Henneke)}
	\label{businessModels}
	When taking a look at the business model of the two rivaling \glspl{ISA} there will be two substantially different approaches. While ARM takes the traditional path of licensing its intellectual property to semiconductor companies, RISC-V stands out with the completely different way of publishing its \gls{ISA} in an open source manner. This includes giving away their \gls{ISA} definition for free, which raises the standard questions criticizing open source material. %TODO: passende Quelle

	Beginning with the classic model of ARM, the following sections will cover the two license models: ARM sells its \glspl{ISA} in various licensing models \cite{ARMLC}. Multiple levels of access are definded within them. The 'Design Start' level includes free access to the IP-Core of the simplest ARM Chips Cortex-M0 and Cortex-M3 as well as the corresponding toolchain and processor models. For a fee between \$0 and \$75K \cite{ARMLC} you can aquire the IP-Core of the Cortex-A5 aswell as the permission for 'single use' chip production. This allows the customer to produce and sell one type of chip for a single purpose e.g. a network controller. For every chip produced, ARM demands a specified royality. The 'Design Start' access level also includes a license for accessing a 'artisan physical IP library', a license for universities, which includes teaching and prototyping and allows non commercial production of own chips without royalties in small quantities. At last there is an '\acrshort{FPGA}' license, which is free and includes a \gls{FPGA} optimized version of the Cortex-M3 and M1, but does not allow production.

	The next level of access is called 'Flexible Access' and contains two license models, one for \$0 to \$75K which allows one tape-out per year. On top of the entry price one pays per used processor design and a royality per produced chip. The other model starts at \$200K per year and uses the same payment additions as the first one. But it allows unlimited tape-outs and includes employee trainings, design tools and design support. \cite{ARMLC}

	Above those access levels, there only officially exists the 'Standard' licensing model. This means one makes a individual contract with ARM.
	Several articles from 2013 \cite{Demerjian2013}\cite{Demerjian2013a} talk about an older licensing model which contains special categories for higher access licenses. The highest of these, often referred as the 'Architectural' license is the only one that allows editing of the \gls{ISA} and developing completely unobstructed. The most prominent companies with such a license are Qualcomm, which develops and sells mobile phone chips and Apple, who just announced a 'Apple Silicon' developed laptop chip based on ARM \cite{Apple2020}. The article also mentions that preparing a license of this form often takes about 6-24 months and states per-chip royalties of about 1-2.5\%. It also notices so called 'foundry contracts' where customers can buy silicon ready ARM designs in cooperation with a silicon foundry. The most prominent example here are the Mali GPUs. This offers customers a fast and easy way to expand their chip with, for example, graphic accelerators.

	In contrast to the ARM license model, RISC-V publishes its intellectual property using the 'Creative Commons Attribution 4.0' license \cite{Waterman2017}\cite{Waterman2017a}. This license allows the user to 'share' and 'adapt'. This means you are free to copy and redistribute as well as modify, change, build upon and sell it commercially. It is not necessary to share changes in an open source manner and you are only restricted by the obligation to give credit to the original licensor \cite{CC}. An important addition is also, that the license cannot be revoked by the licensor. This means everything about RISC-V that is already published will always be free to use.
	Originally founded by Berkley University, the RISC-V \gls{ISA} standard is now managed by the nonprofit organization 'RISC-V International', founded in 2015 \cite{RVIAbout}. As the statutes of the organization include, the association has 'no pecunuary, self-help or commercial purpose' \cite{RVIArt}. Running expenses and further development of the standard do however require a certain liquidity. This is ensured by a membership program surrounding the specification \cite{RVIMem}. Resembling the ARM licensing model, it contains three levels: 'Premier', 'Strategic' and 'Community'. Costing between \$2K and \$250K annually, these levels do not restrict access to the \gls{ISA}, but grant several levels of taking influence on the future development of the standard. This is done through seats in the 'Technical Steering Commitee', speaker slots on conferences and representation on the official RISC-V International website and blog. There are also three 'Strategic Directors', which are elected out of the 'Premier' and 'Strategic' Members and one Academic as well as one Communtiy Director, which is elected by the 'Communtiy' level of members. \cite{RVIAss}

	Beside taking influence in the development process, the membership also includes help in designing \gls{CPU} Cores, teaching for employees and more. It also allows the usage of the trademark 'RISC-V'.

	\subsection{Complexity (Michael Schneider)}
	\label{complexity}
	Risc-V and ARMv8 are both \gls{RISC} based architectures but still different in complexity e.g amount of different implementations, the way to extend the \gls{ISA} and the different instruction formats and assembly operations. In RISC-V the only mandatory instruction set is the Integer instruction set. Those base integer instructions cannot be redefined, only extended by optional instruction sets \cite[page 3f]{Waterman2017}. Further details about the extensions are in chapter \ref{sec:extensibility}.
	
	ARM instead defines the ARMv8 architecture in a completely different way. The ARMv8 already supports many more extensions in the basic version, also called v8.0 \cite[page 60]{Arm2020}. Further extensions are available in later versions, as explained in the chapter \ref{sec:extensibility}.	
	%Because almost all the optional extensions of RISC-V are covered by the basic v8.0, the ARMv8, regarding only the instructions, is at least as complex as a fully extended RISC-V architecture. 
	%All those additional extensions like v8.1 etc. makes the architecture much more complex than the full extended RISC-V.

	The different \glspl{ISA} are able to implement the instruction sets in various ways.
	The RISC-V architecture is able to implement the instruction sets in 3 different word length, a 32-bit (RV32I), a 64-bit (RV64I) and a 128-bit version (RV128I).
	For the 32-bit and the 64-bit implementations are also multiple subversions available, RV32E and RV32G/RV64G. For 128-bit, RV128I is the only 128-bit implementation so far. RV32E is a version with only 15 instead of 31 registers. The subversion RV32G/RV64G is less a own version than a stable release. The RV32G/RV64G combines a basic \gls{ISA} (RV32I or RV64I) plus the different selected standard extensions IMAFD, which are explained in chapter \ref{sec:extensibility}. \cite[page 3ff]{Waterman2017} 

	Also ARMv8 has different implementations, A64, A32 and T32. A64 is the 64-bit version and A32, T32  are both 32-bit versions.
	AArch64 and AArch32 are two different execution states in ARM (AArch64 for 64-bit and AArch32 for 32-bit). These execution states support the A64 instruction set in AArch64 and A32 and T32 in AArch32. While A32 uses fixed 32-bit instruction encodings, T32 is variable, which means it uses both 16-bit and 32-bit instructions. \cite[page 38]{Arm2020}
	% wieder einkommentieren wen noch Wörter übrig.	
	%This is good to optimize your code, because a common instruction selection rule says, if a 16-bit encoding and a 32-bit encoding are available, the 16-bit is the one you should use, to optimize the code density. \cite{Arm2020}
	
	Further the assembly instructions, demonstrated with store/load, and also the related formats are different for ARM and RISC-V.
	To load a value from a RISC-V register, LW, LH or LB is used. The "L" means load and the following character stand for word (32 bit), halfword (16 bit) and byte. LH and LB are signed and can be extended by an "U" (LHU, LBU) to load unsigned values. Those instructions take 2 registers together with an immediate offset. \cite[page 18f]{Waterman2017}

	The store instructions SW, SH and SB are structured in the same way. SW stands for store word, SH store halfword and SB means store byte. The instructions take again two registers, together with an offset.  \cite[slide 30ff]{Berkeley2019} 

	ARM instead has a few more instructions but the basics are almost the same. The (LDR) command can be extended by an B to load only a byte, SB to load a signed byte, H to load a half word, SH to load an signed halfword and SW to load a signed word. To store a value, there are 3 possible ways STR to store the complete register, STRB to store a byte and STRH to store a halfword. These basic load and store commands are followed by: load/store pairs, unscaled offsets and much more. \cite[page 207 - 218]{Arm2020}

	The explained load and store instructions are, just like all other instructions defined in a special format.
	In RISC-V (RV32I) the instructions are summarised to Branch instructions, jump instructions, store instructions, instructions with immediates, arithmetic/logical ops and instructions with upper immediates.
	The arithmetic/logical ops (R-Format) instructions using 3 register inputs, e.g. the add command takes 2 source registers and as a third one, the destination register to store the result.
	The immediate (I-Format) and the upper immediate (U-Format) work in a similar way. Both add an immediate to the source register, but I-type operations only have an immediate up to 12-bit -- which is also supported by load instructions -- and U-type operations have an immediate up to 20-bit. Because of the higher amount of immediate bits, the upper immediates only contain 1 register. Branching (B-Format) instructions -- mostly used for loops -- as well as store (S-Format) instructions take two registers. As last (J-Format) jump instructions are used to jump to a specific address, to define 32-bit address a immediate together with a destination register is used. \cite[slide 10 -64]{Ho}
	
	In the ARMv8 \gls{ISA} (A32) the instructions are structured in a different way, as well as the base version has much more different instructions, e.g. already more than 40 different load and store instructions. ARM contains, data-processing and miscellaneous instructions, Load/Store Word (immediate, literal), Load/Store Word (register), media, branch, system register access and unconditional instructions.	Each instruction is encoded by a 32 bit word containing a condition at the highest positions bits[31:28], followed by an op0 (3-bit) field to define the type of instruction. For every one of the 7 formats further definitions are done and deeper lets say subformats make more specifications for the structure. There are the clear definitions about source and destination registers as well as the size of the immediate are made. \cite[page 4218 - 4278]{Arm2020}.
	
	\subsection{Performance (Alexander Schmid)}
	\label{performance}
	Code size is the performance parameter most influenced by the \gls{ISA} and not by the \gls{CPU}'s implementation,
	given that the \gls{ISA} and the compiler are the only two factors that influence code size.
	Because of this, code size is the most meaningful performance aspect to compare when evaluating the performance of different \glspl{ISA}.
	Given that code size is most critical in embedded applications, the Embench benchmark suite is a good benchmark
	with which to compare code sizes \cite{Patterson2019}. It consists of a number of programs frequently used in embedded
	applications, such as CRC, signal filtering, AES and QR code reading \cite{Patterson2019}.
	When compiling the Embench suite for both RV32IMC (see chapter \ref{sec:extensibility}) as well as 32-bit ARM with the Thumb-2 extension for code compression (called T32 in ARMv8, see chapter \ref{complexity}) using GCC 7,
	the code for RISC-V is approximately 11\% larger than the code for ARM \cite{Perotti2020}.
	Part of this gap in code size can be explained by the relative immaturity of the RISC-V implementation of
	GCC. RISC-V support for GCC was introduced in 2017 and the code size of the Embench suite
	compiled for RISC-V is lower with newer versions of GCC, however it is still larger than the code generated for ARM as of 2019 \cite{Patterson2019}.

	In \cite{Perotti2020} an extension for RISC-V is introduced, called HCC, that contains a number of instructions
	aimed at reducing the code size of RISC-V. This extension brings the code size gap down to 2.2\% for the Embench suite
	and makes the RISC-V code smaller than ARM by 1.75\% in a proprietary IoT benchmark developed by Huawei. \cite{Perotti2020}
	
	For 64-bit code size, the SPEC CPU2006 benchmark, when compiled to both RV64C as well as ARM A64 using GCC 5.2,
	is over 20\% larger on ARM as compared to RISC-V \cite[page 62]{Waterman2016}.
	This difference is mainly caused by the fact that ARM does not include a compressed instruction set like T32 for 64-bit, while RISC-V does.
	Code size is less important in applications where 64-bit \glspl{CPU} are typically used, because these applications
	are not as constrained in program memory size as embedded applications. A more dense 64-bit instruction set does however allow better utilization of the instruction cache,
	leading to better execution time \cite[slide 46]{Celio2016}.

	An issue when comparing execution speed is that the implementation of a specific \gls{CPU} has a far greater impact than the \gls{ISA}.
	One way to isolate the influence of the ISA is by only comparing the dynamic instruction count.
	The dynamic instruction count refers to the number of instructions the \gls{CPU} executes when executing a specific program
	and, like code size, it is only influenced by the \gls{ISA} and compiler.

	For the SPECint portion of the SPEC CPU 2006 benchmark compiled with GCC 5.3, the dynamic instruction count is approximately
	10\% larger for RV64G as compared to ARM A64 \cite[slide 38]{Celio2016}.
	This difference can be explained by the presence of complex memory instructions in ARM that require multiple instructions
	for the same task in RISC-V \cite[slide 40]{Celio2016}.
	These instructions may however be split into multiple micro-operations on an ARM \gls{CPU} via a process called micro-op generation \cite[slide 40]{Celio2016}.
	Similarly, an optimizing RISC-V CPU might execute multiple instructions that often occur together as if they were one instruction.
	This process is called macro-op fusion \cite[slide 16]{Celio2016}.
	When accounting for both micro-op generation as well as macro-op fusion, there is no significant difference in cycle count between RISC-V and ARM
	in the aforementioned SPECint benchmark \cite[slide 38]{Celio2016}.


	\subsection{Extensibility (Michael Schneider)}\label{sec:extensibility}
	To allow to tailor there \glspl{ISA} to specific needs,  RISC-V and ARMv8 define extensions in different ways. While RISC-V defines the basic integer instructions as the only mandatory instruction set \cite[page 3f]{Waterman2017}, ARMv8 defines the more extended ARMv8.0 as the basic version \cite[page 60]{Arm2020}.
	
	RISC-V supports in addition to the integer instructions different extensions. To mark the implemented extensions, representable letters are used. 13 extensions are provided and everyone can add new features on top of the \gls{ISA}, as followes. The M extension for integer multiplication and division, A extension for atomic instructions, C extension for compressed instructions, B extension for bit manipulations, J extension to understand dynamically translated languages, T extension to work with transactional memory, P extension for Packed-\gls{SIMD} instructions and the N extension to support User-Level interrupts. To work with further number formats (floats, vectors) additional to standard integers, V extension (vectors), and the extensions F, D, Q and L are defined for single-, double-, quad- percision and decimal floating points. The implemented extensions further give the name to the \gls{ISA}, e.g. if single floating-points and vectors extend a RV32I together with the integer multiplication, the \gls{ISA} will be named RV32IMFV. \cite[page 31-52, 71-103]{Waterman2017}
	
	ARM provides extensions in a different way. The \gls{ISA} has a base version which contains almost all extensions of RISC-V, called ARMv8.0 (uses A32/T32 or A64 with further extensions) \cite[page 60]{Arm2020}. The ARMv8.0 is already able to work with vectors and floating-points \cite[page 40- 50]{Arm2020}. The higher versions of ARMv8 (ARMv8.1 up to ARMv8.6) add further additional requirements and architectural features. Only the version ARMv8.4 adds only architectural features and no further requirements. \cite[page 60ff]{Arm2020}
	
	Additional to the different versions of the \gls{ISA}, both provide to create custom extensions.
	To create a RISC-V custom extension two steps are important: defining the instructions and include the instruction to the application \cite[page 16 - 21]{Limited2019}. To realise these steps different tools can be used, for example the OVP APIs, which are helpful to simulate the extended processor model \cite{Imperas}.
	To define the instructions, the first step is the decoding of the instruction, to define the fixed fields for instruction class and the fields for source and result register. Later on the defined decoding will be used to decode the instructions from the PC. The instruction behaviour can be done in two different ways, either by simply using a C algorithm function or by using the VMI Morph Time Functions, which is the recommended approach. Finally the custom instructions can be used in C applications after they are added to the processor model. \cite[page 16 - 21]{Limited2019}
	
	ARM added also the possibility to create customized extensions. So far this is only supported for Cortex-M33, but in 2021 ARM wants to add support for the new Cortex-M55 as well. Accelerators can be categorized in the 3 different types. Memory mapped accelerators (connected to memory bus), coprocessor interface (allows to build closely coupled accelerators) and tightly to the CPU coupled accelerators. 
	While decoupled memory mapped accelerators run parallel and unaffected from the CPU, coprocessor and tightly coupled accelerators interact with the CPU and further tightly coupled accelerators are not able to run in parallel with the CPU. To build one of the 3 types of custom instruction only two steps are mandatory to do: 
	\begin{enumerate}
	\item "Providing a configuration file that lists the regions you want to use for adding your own custom instructions." \cite[page 4]{LauranneChoquin2020}
	\item "Building the datapath for your own custom instructions and integrating
	it into the configuration space." \cite[page 4]{LauranneChoquin2020}
	\end{enumerate}
	To finally decode the instruction and control the data path, the logic is automatically configured. \cite[page 2ff]{LauranneChoquin2020}

	\subsection{Ecosystem (Florian Henneke)}
	\label{ecosystem}
	Getting access to the ISA is only the first step in producing and offering self designed silicon.
	The following steps can be broken down roughly into the subsequent points \cite{ARM2019}:
	\begin{enumerate}
		\item Designing the CPU Core.
		\item Checking for compliance to the ISA \cite{Bartley2020}.
		\item Testing the core for formal correctness \cite{Bartley2020}.
		\item Testing for function with random and edge case data \cite{Bartley2020}.
		\item Finding a factory partner for production.
		\item Set up at least a software toolchain for creating and compiling applications on your hardware. It is also advantageous, if the toolchain contains a hardware abstraction layer and is sufficiently tested.
	\end{enumerate}
	ARM makes this process significantly easier: They already supply a completed CPU Core, which is compliant to their \glspl{ISA} and tested formally as well as in function. It is also proven many times in existing hardware. The ARM package also includes a complete software toolchain which enables chip designers to create chips according to their own specification within the ARM environment. Having a rather firm ecosystem, they are also able to provide a hardware abstracion layer as well as a compiler toolchain \cite{CMSIS}. Lastly they offer connections to chip foundries, who already have experience in manufacturing ARM based silicon \cite{ARM2019}.
	A good ecosystem for the end user, consisting of well tested compiler toolchains \cite{ARMGNU} and operating systems, also exists \cite{Microsoft2020}\cite{RedHat}.

	What RISC-V currently offers is completely different. The only thing obtained from RISC-V International is the \gls{ISA} definition. This does not mean, that the chip designer must go through the aforementioned list on their own. With a supportive community for RISC-V one is able to set one's own starting point in the design process. For example one could start at a finished, probably already compliance checked and tested core \cite{RVCores} and adapt it according to one's use cases. The core implementation also dictates the choice of design toolchain. If one wants to check their extended design, there are already some verification and testing tools available \cite{Bartley2020}. All those cores and tools can however be published under another license than the \gls{ISA} specification. This means the publisher can also limit the freedom that the chip designer has. With a production ready core, one must find a silicon production partner for himself.
	At last, one has to provide an appropriate toolchain for one's chip. This is easy, if the core provider already provides one \cite{SiFive} that is suitable for one's changed core or can be built with community driven toolchain generators \cite{NG}.
	In case of operating systems, the end user is of course able to compile embedded operating systems like Zephyr \cite{LinuxFoundation} or FreeRTOS \cite{Aws2020}, desktop operating systems however are not yet supported. Nevertheless it is proven, that Linux is able to run on RISC-V based processors \cite{SiFivea}.

\section{Discussion}
\label{ref:discussion}

	\subsection{Performance (Alexander Schmid)}
	32-bit ARM with the T32 extension features a lower code size than RV32IMC in two popular benchmarks \cite{Perotti2020}.
	This poses a significant advantage on embedded microcontrollers with a small program memory.
	Currently, this disadvantage can be mitigated on RISC-V with custom ISA extensions.

	In the case of 64-bit ARM and RV64G(C), RISC-V offers a significantly lower code size, but it also has a larger
	dynamic instruction count. The authors of \cite{Celio2016} find no difference in cycle count
	between the two \glspl{ISA}, after applying a model that takes into account both micro-op generation as well as macro-op fusion.
	However, this is based on the assumption that each register writeback is translated into a single micro-op,
	which is not verified against actual ARM \glspl{CPU} \cite[slide 40]{Celio2016}.

	A more accurate comparison of the influence of the \gls{ISA} on a \gls{CPU}s cycle count could be gained
	by simulating two \glspl{CPU} with as many of the same components as possible, adapted for each of the two \glspl{ISA}.
	This is done for ARM and x86-64 in \cite{Akram2017}.

	Ultimately, the influence of \gls{ISA}-specific characteristics plays a lesser role for a \gls{CPU}'s performance
	than the optimization performed for a specific implementation of that \gls{ISA}.
	As such, the largest factor determining which \gls{ISA} will feature faster processors is simply the amount of investment
	large companies will put into an optimizing \gls{CPU} implementing the \gls{ISA} \cite{Blem2013}.
	This can be studied by empirically comparing common \glspl{CPU} of both \glspl{ISA}, as done in \cite{Blem2013} for ARM and
	x86-64, as soon as enough RISC-V \glspl{CPU} are on the market.
	
	\subsection{Complexity (Michael Schneider)}
	The complexity is influenced by different aspects, as shown in chapter \ref{complexity}.
	 Due to the higher amount of instructions in ARM (see chapter \ref{complexity}) it is more difficult to understand the differences between every single instruction. RISC-V instead has less instructions that is why the difference between each instruction is easier to grasp. 
	 For the higher amount of instructions ARM has also more instruction formats, which are, compared to RISC-V, a bit variable due to the different subversions (see chapter \ref{complexity}).
	%Also the differences in the base versions with corresponding extensions (shown in chapter \ref{sec:extensibility}) and the amount of instructions and formats (elaborated in \ref{complexity}) lead to differences in complexity.
	
	Both \glspl{ISA} define a way for 32-bit and 64-bit. While ARM defines with T32 a version, which works with 16-bit and 32-bit \cite[page 38]{Arm2020}, RISC-V provides the C-extension for 16-bit instruction encoding for the 32-bit version (RV32), the 64-bit version (RV64) and the 128-bit version (RV128) \cite[page67]{Waterman2017}.
	%ARM has much more instruction formats with much more instructions which makes it more complex to build, but if it is done its more restrict for the future. Complex features, which are maybe not supported in RISC-V or which are not implemented, because the are obsolete, are part of the version of ARM. This is figured out by comparing the formats and mandatory instructions of both the RISC-V and ARM, as it is done in chapter \ref{complexity} and chapter \ref{sec:extensibility}.

\subsection{Extensibility (Michael Schneider)} \label{dis:Extensibility}
	To discuss the extensibility of the architectures, two different ways to extend \glspl{ISA} need to be considered, the use of defined standard extensions and the use of custom extensions. 
	
	The RISC-V architecture has only one mandatory component (integer instruction set) \cite[page 3f]{Waterman2017}, while the basic ARM version (ARMv8.0) includes already many extension \cite[page 8120] {Arm2020}. This results for RISC-V in an only as complex as needed CPU, because only the mandatory instruction sets have to be implemented \cite[page 3f]{Waterman2017}. The ARM version instead, which includes a large amount of instructions, results in a perhaps more complex CPU (unnecessarily implemented instructions). Related to the realisation of extensions, as shown in chapter \ref{sec:extensibility}, the ARM \gls{ISA} forces to the implementation of instructions and features, which are maybe not needed for the given CPU, but could be useful in the future.

	The two \glspl{ISA} feature different approaches to custom extensions, which one is better depends on personal preference. While ARM is very strict and a official white paper \cite{LauranneChoquin2020} defines the way to do, RISC-V doesn't define a official way and there are a lot of tool triggered projections, like the one from Imperas \cite{Limited2019} are given, but the loose definition of RISC-V makes it a bit more complex to understand the process.

	\subsection{Business Model and Ecosystem (Florian Henneke)}
	Because the Business Model and the Ecosystem are strongly connected from a chip developers perspective, while deciding which architecture to use, they will be discussed together in the following section.

	In summary, there are three main points to consider when choosing a architecture from an economical point of view: the price, how much effort you have to put in and how much revenue can be expected.

	Starting with the financial aspect, theoretically both platforms can be free. However considering, that one is not allowed to commercially produce ARM based chips with the lowest tier licenses and has to pay royalties \cite{ARMLC}, RISC-V gets, beacuse of beeing totally free, an advantage at the fixed expenses.

	Anyhow most of the expenses will not originate from the license, but will develop during the development phase (\ref{ecosystem}) in form of the amount of work, that has to be done and in other licenses concerning development and testing software. ARM already includes many of these upcoming costs in their licenses by offering an already designed and tested core as well as related software \cite{ARM2019}. In case of RISC-V the semiconductor company has to choose and evaluate their options at every step, which definitely creates a lot of work, before they can even start with the main design, but can also result in less work down the development path or costs as low as zero in terms of software licensing.

	Finally developing and offering an own ecosystem for the end user can also create additinal costs, but defintely has a big influence on the revenue stream and the acceptance in the end user community. For a chip with little additions to the provided core, this step is already done by ARM. Looking at RISC-V, this depends on the choosen core. Here again, the RISC-V route can be as optimal as the ARM way, but can also be worse. Eventually the chip use case has also to be considered. While ARM already supports many operting systems, RISC-V has not yet a really usable operating system environment (\ref{ecosystem}).

	Ultimately the decision depends on what type of instition you represent (Can you choose low tier ARM licenses 
	and achieve your goal?), what you want to achieve (Is there a future interest in developing more chips or is the effort only for one chip?), what resources you have (Can you afford higher development costs for bigger future revenue?) and what risk you can take (Do you want to take the risk of going with a new platform or do you want to take the proven way?).


\section{Conclusion and Outlook}
\label{ref:conclusion}
	\subsection{Summary of results (Alexander Schmid)}
	The most striking difference between the two \glspl{ISA} is their business models as described in chapter \ref{businessModels}.
	ARM sells ready-to-use \gls{CPU} core designs, offers extensive support to their customers and only allows the development of new
	ARM compatible \gls{CPU} cores with their most expensive license.
	RISC-V permits anyone to implement a compatible \gls{CPU} free of charge, but offers no services beyond the specification of the \gls{ISA}.
	Anyone looking to obtain a ready-to-use RISC-V \gls{CPU} core design or requiring support integrating the core into an integrated circuit
	must obtain those from a third party.

	Another major difference lies in the \glspl{ISA}' complexity and extensibility (chapter \ref{complexity} and \ref{sec:extensibility}).
	While ARM features a large base \gls{ISA} with only limited support for custom extensions, RISC-V features a more modular
	approach with a small base \gls{ISA} and most features being specified in the form of optional extensions with custom extensions being
	encouraged.

	There are minor differences in code size between the two \glspl{ISA} with ARM having a smaller 32-bit code size and RISC-V having a
	smaller 64-bit code size. There is no significant inherent difference in execution speed as described in chapter \ref{performance}.

	Lastly, the ecosystem is a major advantage of ARM with extensive toolchain and compiler support. Additionally, most major operating systems
	support ARM in some form or another, as described in chapter \ref{ecosystem}.
	In contrast, the only operating systems that can currently be run on RISC-V is Linux along with various embedded and IOT operating systems.
	No major commercial operating system currently supports RISC-V.

	\subsection{Interpretation of results (Alexander Schmid)}
	\label{ref:interpretation}
	RISC-V's permissive licensing model allows for a much lower barrier to entry into the \gls{CPU} market for new designers
	by eliminating the need to pay large upfront licensing costs.
	
	This is compounded by the modularity of the RISC-V \gls{ISA}, allowing designers to quickly build a compliant RISC-V \gls{CPU}
	by implementing the small base \gls{ISA} and only implementing additional extensions as needed (see chapter \ref{sec:extensibility}).

	The fact that there are only minor differences in performance between the two \glspl{ISA} shows that RISC-V can
	compete with established \glspl{ISA} in all applications, from embedded to high performance computing (see chapter \ref{performance}).

	The main challenge for RISC-V to break into markets beyond embedded systems, is software support.
	
	RISC-V may possibly gain market share in mobile devices, given that the Android operating
	system is based on Linux and most user-space applications
	run on a Java Virtual Machine (JVM) \cite{Ehringer2010}. Due to this, only
	the Android operating system itself and its JVM need to be
	ported to RISC-V for many mobile applications to
	become available on RISC-V.

	\subsection{Future directions (Michael Schneider)}
	\label{ref:future}
	%As of 2020, only three of the five planned base \glspl{ISA} and only 8 of the 17 planned extensions of RISC-V have been ratified.
	%This shows that the RISC-V \gls{ISA} is still very much in its infancy, nevertheless there has already been significant interest in RISC-V.

	%The American embargo of the chinese silicon manufacturer Huawei \cite{Lee2019} in conjunction with the pending acquisition of ARM by the American silicon
	%manufacturer Nvidia \cite{Shead2020} spark uncertainty among ARM's customer base.
	%This could lead to increased investment into RISC-V over ARM, especially by Chinese silicon manufacturers such as Huawei.
	The results of the chapter \ref{ref:concept} and the resulting discussion \ref{ref:discussion} try to compare the advantages and disadvantages of both, the RISC-V and the ARM architecture. Most time the advantages and disadvantages depend on different influences, like personal preferences, resources and so on. To clearly define the benefits and drawbacks of the \glspl{ISA} it would be worth to analyse the surrounding conditions to weigh the results to them. A further question would be, if there are some regions, where RISC-V is clearly the better option compared to ARM and if it is possible for RISC-V to gain a nameable market share of ARM. 
\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
